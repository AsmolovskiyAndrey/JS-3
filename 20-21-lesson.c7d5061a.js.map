{"mappings":";;AAsQmBA,WACjB,MAIMC,EAHU,CAAC,EAAG,EAAG,GAGSC,KAAIF,MAAMG,UACjBC,MAAM,8CAAoBD,MACjCE,SAIZC,QAAcC,QAAQC,IAAIP,GAC9BQ,QAAQC,IAAIJ,EAAM,EAGtBK","sources":["src/js/02.js"],"sourcesContent":["//! =================================== CRUD ==========================================================\n\n// Будем делать запросы к JSONPlaceholder API, который предоставляет коллекцию не настоящих постов в ресурсе / posts,\n// представленных объектами со свойствами id, author и body.\n\n//* Чтение\n\n// HTTP - метод GET используется для получения существующих данных.Метод fetch() должен отправить на сервер GET - запрос без тела.\n// Бэкенд, по получению запроса, обработает его и в ответе вернет необходимые ресурсы.\n// Получим массив всех постов.Для этого обращаемся к ресурсу / posts описанному в документации бэкенда.\n// Метод fetch() по умолчанию делает GET - запрос, поэтому переопределять опции запроса не обязательно.\n    \n// fetch(\"https://jsonplaceholder.typicode.com/posts\")\n//     .then(response => response.json())\n//     .then(posts => console.log(posts))\n//     .catch(error => console.log(error));\n\n// Получим один пост по идентификатору(свойство id) добавив его к ресурсу / posts /: postId.Последняя часть этого пути называется динамический параметр и в документации описывается как / ресурс /: параметр.\n// Ресурс неизменен, это путь к целой коллекции, а значение параметра меняется для каждого её элемента.\n\n// // Change this number to fetch different post\n// const postId = 1;\n// fetch(`https://jsonplaceholder.typicode.com/posts/${postId}`)\n//     .then(response => response.json())\n//     .then(post => console.log(post))\n//     .catch(error => console.log(error));\n\n\n//* Создание\n\n// Метод POST используется для добавления нового ресурса.Метод fetch() должен отправить на сервер POST - запрос,\n// в теле которого будет объект с полями author и body, идентификатор будет автоматически создан базой данных.\n// Результатом такого запроса будет объект добавленный в базу данных.\n\n// const postToAdd = {\n//     author: \"Mango\",\n//     body: \"CRUD is awesome\",\n// };\n\n// const options = {\n//     method: \"POST\",\n//     body: JSON.stringify(postToAdd),\n//     headers: {\n//     \"Content-Type\": \"application/json; charset=UTF-8\",\n//     },\n// };\n\n// fetch(\"https://jsonplaceholder.typicode.com/posts\", options)\n//     .then(response => response.json())\n//     .then(post => console.log(post))\n//     .catch(error => console.log(error));\n\n// Делаем запрос на создание поста обращаясь к ресурсу / posts, но в настройках метода fetch() изменяем HTTP - метод на POST.\n// Так бэкенд знает, что нужно не прочитать уже существующее, а создать новый ресурс в этой коллекции.\n// Тело запроса должно быть строкой, потому что протокол HTTP передает все как текст.При передаче сложных типов данных,\n// их обязательно необходимо привести к строке методом JSON.stringify().Не забываем указать заголовок Content - Type, который уточняет для бэкенда тип передаваемых данных.\n// В ответ, если все хорошо, получим JSON с добавленным id. Идентификатор будет уникальным для каждого объекта. {author: 'Mango', body: 'CRUD is awesome', id: 101}\n\n//* Обновление\n\n// Методы PUT и PATCH используются для обновления существующих данных.Какой метод использовать будет написано в документации бэкенда.\n// Метод fetch() должен отправить на сервер запрос, в теле которого необходимо указать объект с полями для изменения.\n// Путь указывает в какой коллекции и какой элемент мы хотим обновить.Бекенд, по получению запроса, обработает его и в ответе вернет обновленный ресурс.\n// В ответ, если все хорошо, получим обновленный объект. {userId: 1, id: 1, title: 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit', body: 'CRUD is really awesome'}\n\n// // Change value of id property to update different post\n// const postToUpdate = {\n//     id: 1,\n//     body: \"CRUD is really awesome\",\n// };\n\n// const options = {\n//     method: \"PATCH\",\n//     body: JSON.stringify(postToUpdate),\n//     headers: {\n//     \"Content-Type\": \"application/json; charset=UTF-8\",\n//     },\n// };\n\n// fetch(`https://jsonplaceholder.typicode.com/posts/${postToUpdate.id}`, options)\n//     .then(response => response.json())\n//     .then(post => console.log(post))\n//     .catch(error => console.log(\"ERROR\" + error));\n\n// ИНТЕРЕСНО\n//? Метод PATCH заменяет в существующем ресурсе значения переданные в теле запроса свойств. Метод PUT полностью заменяет ресурс.\n\n//* Удаление\n\n// Метод DELETE используется для удаления существующих данных.Метод fetch() должен отправить на сервер DELETE - запрос без тела.\n// Путь указывает в какой коллекции и какой элемент мы хотим удалить.\n// Бекенд, по получению запроса, обработает его, удалит ресурс из коллекции и в ответе вернет статус результата.  Post deleted\n\n// const postIdToDelete = 1;\n\n// fetch(`https://jsonplaceholder.typicode.com/posts/${postIdToDelete}`, {\n//     method: \"DELETE\",\n// })\n//     .then(() => console.log(\"Post deleted\"))\n//     .catch(error => console.log(\"Error:\", error));\n\n\n//! ===================================================== Асинхронные функции ===========================================================\n\n// Асинхронные функции помогают избавиться от коллбэков и вложенных конструкций.При этом они отлично работают в связке с методами then() и catch (),\n// потому что гарантированно возвращают промис.\n\n// const fetchFriends = async () => {\n//     const token = await fetch(\"my-api.com/me\");\n//     const user = await fetch(`my-api.com/profile?token=${token}`);\n//     const friends = await fetch(`my-api.com/users/${user.id}/friends`);\n//     return friends;\n// };\n\n// fetchFriends()\n//     .then(friends => console.log(friends))\n//     .catch(error => console.error(error));\n\n//todo Синтаксис async/await\n\n// Асинхронные функции(async / await) - удобный способ написания асинхронного кода, который внешне становится похож на синхронный.\n// В основе синтаксиса async / await лежат промисы, поэтому он не блокирует главный поток выполнения программы.\n\n// Для объявления асинхронной стрелочной функции, перед списком параметров добавляем ключевое слово async.\n// Внутри неё можно использовать оператор await и справа от него поставить что - то, что вернёт промис.Метод response.json() также возвращает промис, поэтому ставим await.\n\n// const fetchUsers = async () => {\n//     const response = await fetch(\"https://jsonplaceholder.typicode.com/users\");\n//     const users = await response.json();\n//     return users;\n// };\n\n// fetchUsers().then(users => console.log(users));\n\n// Когда интерпретатор встречает await, он приостановливает выполнение этой функции(не всего скрипта) и ждет, пока не выполнится промис справа от await.\n// Как только промис выполнился - исполнение функции возобновляется и на строке ниже нам доступен результат асинхронной операции.\n\n// Оператор await можно использовать только в теле асинхронной (async) функции.\n// Оператор await приостанавливает функцию пока промис не выполнится (fulfilled или rejected).\n// Если промис выполнился успешно (fulfilled), оператор await вернет его значение.\n// Если промис был отклонен с ошибкой (rejected), оператор await выбросит ошибку.\n// Асинхронная функция всегда возвращает промис, поэтому любое возвращаемое значение будет его значением.\n// Если не указать возвращаемое значение, вернется промис со значением undefined.\n\n//* Любая функция может быть асинхронной, будь - то метод обьекта, класса, коллбэк, объявление или инлайн функция.\n//* Все они смогут использовать оператор await и обязательно вернут промис, потому что будут асинхронными функциями.\n\n// // Function declaration\n// async function foo() {\n//   // ...\n// }\n// // Functional expression\n// const foo = async function () {\n//   // ...\n// };\n// // Arrow function\n// const foo = async () => {\n//   // ...\n// };\n// // Object method\n// const user = {\n//   async foo() {\n//     // ...\n//   },\n// };\n// // Class method\n// class User {\n//   async foo() {\n//     // ...\n//   }\n// }\n\n//todo Обработка ошибок\n\n//* Если результат асинхронной функции(промис) не используется во внешнем коде, ошибки обрабатываются в теле функции конструкцией try...catch.\n// Значение параметра error в блоке catch это ошибка которую сгенерирует await если промис будет отклонен.\n\n// const fetchUsers = async () => {\n//   try {\n//     const response = await fetch(\"https://jsonplaceholder.typicode.com/users\");\n//     const users = await response.json();\n//     console.log(users);\n//   } catch (error) {\n//     console.log(error.message);\n//   }\n// };\n\n// fetchUsers();\n\n//* Если результат асинхронной функции(промис) используется во внешнем(глобальном) коде, то есть вне других асинхронных функций, ошибки обрабатываются коллбэком методом catch ().\n// Значение параметра error в методе catch () это ошибка которую сгенерирует await если промис будет отклонен.\n\n// const fetchUsers = async () => {\n//   const response = await fetch(\"https://jsonplaceholder.typicode.com/users\");\n//   const users = await response.json();\n//   return users;\n// };\n\n// fetchUsers()\n//   .then(users => console.log(users))\n//   .catch(error => console.log(error));\n\n//?Так работать не будет - await можно использовать только в теле асинхронной функции.====================\n// const fetchUsers = async () => {\n//   const response = await fetch(\"https://jsonplaceholder.typicode.com/users\");\n//   const users = await response.json();\n//   return users;\n// };\n\n// ❌ SyntaxError: await is only valid in async function\n// const users = await fetchUsers();\n//?=============================================================\n\n//* Если результат асинхронной функции используется в другой асинхронной функции, ошибки обрабатываются конструкцией try...catch.\n// Значение параметра error в блоке catch это ошибка которую сгенерирует await если промис будет отклонен.\n\n// const fetchUsers = async () => {\n//   const response = await fetch(\"https://jsonplaceholder.typicode.com/users\");\n//   const users = await response.json();\n//   return users;\n// };\n\n// const doStuff = async () => {\n//   try {\n//     const users = await fetchUsers();\n//     console.log(users);\n//   } catch (error) {\n//     console.log(error.message);\n//   }\n// };\n\n// doStuff();\n\n//todo Параллельные запросы\n\n// Если одновременно необходимо сделать несколько запросов, использовать синтаксис async / await нужно очень аккуратно.\n// В следующем примере будут выполнены три последовательных запроса, потому что выполнение асинхронной функции приостанавливается когда интерпретатор встречает await.\n// Кроме того, парс результатов запросов также будет последовательный, что займет больше времени.\n\n// const fetchUsers = async () => {\n//   const baseUrl = \"https://jsonplaceholder.typicode.com\";\n//   const firstResponse = await fetch(`${baseUrl}/users/1`);\n//   const secondResponse = await fetch(`${baseUrl}/users/2`);\n//   const thirdResponse = await fetch(`${baseUrl}/users/3`);\n\n//   const firstUser = await firstResponse.json();\n//   const secondUser = await secondResponse.json();\n//   const thirdUser = await thirdResponse.json();\n\n//   console.log(firstUser, secondUser, thirdUser);\n// };\n\n// fetchUsers();\n\n// На вкладке Network хорошо видно, что запуск каждого последующего запроса ожидает пока завершится предыдущий.\n// То есть выолняются они последовательно, что занимает больше времени, которое равно сумме длительностей всех запросов.\n// Это нормально, если запросы зависят друг от друга, то есть следующий использует результат предыдущего.\n\n// Concurrent requests\n// В нашем случае они полностью независимы, поэтому нужно запустить их параллельно.Для этого создаётся массив промисов, после чего используется метод Promise.all(),\n// для ожидания их выполнения.Массив промисов создается методами map(), filter() и так далее, зависит от задачи.\n\nconst fetchUsers = async () => {\n  const baseUrl = \"https://jsonplaceholder.typicode.com\";\n  const userIds = [1, 2, 3];\n\n  // 1. Создаём массив промисов\n  const arrayOfPromises = userIds.map(async userId => {\n    const response = await fetch(`${baseUrl}/users/${userId}`);\n    return response.json();\n  });\n\n  // 2. Запускаем все промисы параллельно и ждем их завершения\n  const users = await Promise.all(arrayOfPromises);\n    console.log(users);\n};\n\nfetchUsers();\n\n// При таком подходе запросы запускаются параллельно, что экономит время ожидания их выполнения, которое равно длительности самого «медленного» из них.\n// Такой приём подходит только если запросы не зависят друг от друга."],"names":["async","arrayOfPromises","map","userId","fetch","json","users","Promise","all","console","log","$49ed73bccce489d1$var$fetchUsers"],"version":3,"file":"20-21-lesson.c7d5061a.js.map"}